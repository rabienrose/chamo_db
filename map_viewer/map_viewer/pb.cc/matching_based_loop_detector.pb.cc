// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: matching-based-loopclosure/matching_based_loop_detector.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "matching-based-loopclosure/matching_based_loop_detector.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace matching_based_loopclosure {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatchingBasedLoopDetector_reflection_ = NULL;
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_DescriptorIndexToKeypoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatchingBasedLoopDetector_DescriptorIndexToKeypoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_DatabaseEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatchingBasedLoopDetector_DatabaseEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_InvertedMultiIndexInterface_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatchingBasedLoopDetector_InvertedMultiIndexInterface_reflection_ = NULL;
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_reflection_ = NULL;
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto() {
  protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "matching-based-loopclosure/matching_based_loop_detector.proto");
  GOOGLE_CHECK(file != NULL);
  MatchingBasedLoopDetector_descriptor_ = file->message_type(0);
  static const int MatchingBasedLoopDetector_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, descriptor_index_to_keypoint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, database_entries_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, descriptor_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, inverted_multi_index_interface_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, keyframe_id_to_num_descriptors_),
  };
  MatchingBasedLoopDetector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatchingBasedLoopDetector_descriptor_,
      MatchingBasedLoopDetector::default_instance_,
      MatchingBasedLoopDetector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatchingBasedLoopDetector));
  MatchingBasedLoopDetector_DescriptorIndexToKeypoint_descriptor_ = MatchingBasedLoopDetector_descriptor_->nested_type(0);
  static const int MatchingBasedLoopDetector_DescriptorIndexToKeypoint_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DescriptorIndexToKeypoint, descriptor_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DescriptorIndexToKeypoint, vertex_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DescriptorIndexToKeypoint, frame_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DescriptorIndexToKeypoint, keypoint_index_),
  };
  MatchingBasedLoopDetector_DescriptorIndexToKeypoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatchingBasedLoopDetector_DescriptorIndexToKeypoint_descriptor_,
      MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance_,
      MatchingBasedLoopDetector_DescriptorIndexToKeypoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DescriptorIndexToKeypoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DescriptorIndexToKeypoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatchingBasedLoopDetector_DescriptorIndexToKeypoint));
  MatchingBasedLoopDetector_DatabaseEntry_descriptor_ = MatchingBasedLoopDetector_descriptor_->nested_type(1);
  static const int MatchingBasedLoopDetector_DatabaseEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DatabaseEntry, vertex_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DatabaseEntry, frame_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DatabaseEntry, projected_image_),
  };
  MatchingBasedLoopDetector_DatabaseEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatchingBasedLoopDetector_DatabaseEntry_descriptor_,
      MatchingBasedLoopDetector_DatabaseEntry::default_instance_,
      MatchingBasedLoopDetector_DatabaseEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DatabaseEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_DatabaseEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatchingBasedLoopDetector_DatabaseEntry));
  MatchingBasedLoopDetector_InvertedMultiIndexInterface_descriptor_ = MatchingBasedLoopDetector_descriptor_->nested_type(2);
  static const int MatchingBasedLoopDetector_InvertedMultiIndexInterface_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_InvertedMultiIndexInterface, inverted_multi_index_),
  };
  MatchingBasedLoopDetector_InvertedMultiIndexInterface_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatchingBasedLoopDetector_InvertedMultiIndexInterface_descriptor_,
      MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance_,
      MatchingBasedLoopDetector_InvertedMultiIndexInterface_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_InvertedMultiIndexInterface, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_InvertedMultiIndexInterface, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatchingBasedLoopDetector_InvertedMultiIndexInterface));
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_ = MatchingBasedLoopDetector_descriptor_->nested_type(3);
  static const int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors, keyframe_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors, num_descriptors_),
  };
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_,
      MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance_,
      MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors));
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_descriptor_ = MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_->nested_type(0);
  static const int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId, vertex_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId, frame_index_),
  };
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_descriptor_,
      MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance_,
      MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatchingBasedLoopDetector_descriptor_, &MatchingBasedLoopDetector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatchingBasedLoopDetector_DescriptorIndexToKeypoint_descriptor_, &MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatchingBasedLoopDetector_DatabaseEntry_descriptor_, &MatchingBasedLoopDetector_DatabaseEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatchingBasedLoopDetector_InvertedMultiIndexInterface_descriptor_, &MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_, &MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_descriptor_, &MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto() {
  delete MatchingBasedLoopDetector::default_instance_;
  delete MatchingBasedLoopDetector_reflection_;
  delete MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance_;
  delete MatchingBasedLoopDetector_DescriptorIndexToKeypoint_reflection_;
  delete MatchingBasedLoopDetector_DatabaseEntry::default_instance_;
  delete MatchingBasedLoopDetector_DatabaseEntry_reflection_;
  delete MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance_;
  delete MatchingBasedLoopDetector_InvertedMultiIndexInterface_reflection_;
  delete MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance_;
  delete MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_reflection_;
  delete MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance_;
  delete MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_reflection_;
}

void protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::common::proto::protobuf_AddDesc_maplab_2dcommon_2fid_2eproto();
  ::loop_closure::proto::protobuf_AddDesc_inverted_2dmulti_2dindex_2finverted_5fmulti_5findex_2eproto();
  ::loop_closure::proto::protobuf_AddDesc_descriptor_2dprojection_2fprojected_5fimage_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n=matching-based-loopclosure/matching_ba"
    "sed_loop_detector.proto\022 matching_based_"
    "loopclosure.proto\032\026maplab-common/id.prot"
    "o\032/inverted-multi-index/inverted_multi_i"
    "ndex.proto\032+descriptor-projection/projec"
    "ted_image.proto\"\210\t\n\031MatchingBasedLoopDet"
    "ector\022{\n\034descriptor_index_to_keypoint\030\001 "
    "\003(\0132U.matching_based_loopclosure.proto.M"
    "atchingBasedLoopDetector.DescriptorIndex"
    "ToKeypoint\022c\n\020database_entries\030\002 \003(\0132I.m"
    "atching_based_loopclosure.proto.Matching"
    "BasedLoopDetector.DatabaseEntry\022\030\n\020descr"
    "iptor_index\030\003 \001(\005\022\177\n\036inverted_multi_inde"
    "x_interface\030\004 \001(\0132W.matching_based_loopc"
    "losure.proto.MatchingBasedLoopDetector.I"
    "nvertedMultiIndexInterface\022~\n\036keyframe_i"
    "d_to_num_descriptors\030\005 \003(\0132V.matching_ba"
    "sed_loopclosure.proto.MatchingBasedLoopD"
    "etector.KeyframeIdToNumDescriptors\032\207\001\n\031D"
    "escriptorIndexToKeypoint\022\030\n\020descriptor_i"
    "ndex\030\001 \001(\005\022#\n\tvertex_id\030\002 \001(\0132\020.common.p"
    "roto.Id\022\023\n\013frame_index\030\003 \001(\r\022\026\n\016keypoint"
    "_index\030\004 \001(\r\032\206\001\n\rDatabaseEntry\022#\n\tvertex"
    "_id\030\001 \001(\0132\020.common.proto.Id\022\023\n\013frame_ind"
    "ex\030\002 \001(\r\022;\n\017projected_image\030\003 \001(\0132\".loop"
    "_closure.proto.ProjectedImage\032c\n\033Inverte"
    "dMultiIndexInterface\022D\n\024inverted_multi_i"
    "ndex\030\001 \001(\0132&.loop_closure.proto.Inverted"
    "MultiIndex\032\365\001\n\032KeyframeIdToNumDescriptor"
    "s\022v\n\013keyframe_id\030\001 \001(\0132a.matching_based_"
    "loopclosure.proto.MatchingBasedLoopDetec"
    "tor.KeyframeIdToNumDescriptors.KeyframeI"
    "d\022\027\n\017num_descriptors\030\003 \001(\r\032F\n\nKeyframeId"
    "\022#\n\tvertex_id\030\001 \001(\0132\020.common.proto.Id\022\023\n"
    "\013frame_index\030\002 \001(\r", 1378);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "matching-based-loopclosure/matching_based_loop_detector.proto", &protobuf_RegisterTypes);
  MatchingBasedLoopDetector::default_instance_ = new MatchingBasedLoopDetector();
  MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance_ = new MatchingBasedLoopDetector_DescriptorIndexToKeypoint();
  MatchingBasedLoopDetector_DatabaseEntry::default_instance_ = new MatchingBasedLoopDetector_DatabaseEntry();
  MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance_ = new MatchingBasedLoopDetector_InvertedMultiIndexInterface();
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance_ = new MatchingBasedLoopDetector_KeyframeIdToNumDescriptors();
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance_ = new MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId();
  MatchingBasedLoopDetector::default_instance_->InitAsDefaultInstance();
  MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance_->InitAsDefaultInstance();
  MatchingBasedLoopDetector_DatabaseEntry::default_instance_->InitAsDefaultInstance();
  MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance_->InitAsDefaultInstance();
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance_->InitAsDefaultInstance();
  MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto {
  StaticDescriptorInitializer_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto() {
    protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  }
} static_descriptor_initializer_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MatchingBasedLoopDetector_DescriptorIndexToKeypoint::kDescriptorIndexFieldNumber;
const int MatchingBasedLoopDetector_DescriptorIndexToKeypoint::kVertexIdFieldNumber;
const int MatchingBasedLoopDetector_DescriptorIndexToKeypoint::kFrameIndexFieldNumber;
const int MatchingBasedLoopDetector_DescriptorIndexToKeypoint::kKeypointIndexFieldNumber;
#endif  // !_MSC_VER

MatchingBasedLoopDetector_DescriptorIndexToKeypoint::MatchingBasedLoopDetector_DescriptorIndexToKeypoint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::InitAsDefaultInstance() {
  vertex_id_ = const_cast< ::common::proto::Id*>(&::common::proto::Id::default_instance());
}

MatchingBasedLoopDetector_DescriptorIndexToKeypoint::MatchingBasedLoopDetector_DescriptorIndexToKeypoint(const MatchingBasedLoopDetector_DescriptorIndexToKeypoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::SharedCtor() {
  _cached_size_ = 0;
  descriptor_index_ = 0;
  vertex_id_ = NULL;
  frame_index_ = 0u;
  keypoint_index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingBasedLoopDetector_DescriptorIndexToKeypoint::~MatchingBasedLoopDetector_DescriptorIndexToKeypoint() {
  // @@protoc_insertion_point(destructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  SharedDtor();
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::SharedDtor() {
  if (this != default_instance_) {
    delete vertex_id_;
  }
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_DescriptorIndexToKeypoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatchingBasedLoopDetector_DescriptorIndexToKeypoint_descriptor_;
}

const MatchingBasedLoopDetector_DescriptorIndexToKeypoint& MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  return *default_instance_;
}

MatchingBasedLoopDetector_DescriptorIndexToKeypoint* MatchingBasedLoopDetector_DescriptorIndexToKeypoint::default_instance_ = NULL;

MatchingBasedLoopDetector_DescriptorIndexToKeypoint* MatchingBasedLoopDetector_DescriptorIndexToKeypoint::New() const {
  return new MatchingBasedLoopDetector_DescriptorIndexToKeypoint;
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MatchingBasedLoopDetector_DescriptorIndexToKeypoint*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(descriptor_index_, keypoint_index_);
    if (has_vertex_id()) {
      if (vertex_id_ != NULL) vertex_id_->::common::proto::Id::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatchingBasedLoopDetector_DescriptorIndexToKeypoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 descriptor_index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &descriptor_index_)));
          set_has_descriptor_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vertex_id;
        break;
      }

      // optional .common.proto.Id vertex_id = 2;
      case 2: {
        if (tag == 18) {
         parse_vertex_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vertex_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_frame_index;
        break;
      }

      // optional uint32 frame_index = 3;
      case 3: {
        if (tag == 24) {
         parse_frame_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_index_)));
          set_has_frame_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_keypoint_index;
        break;
      }

      // optional uint32 keypoint_index = 4;
      case 4: {
        if (tag == 32) {
         parse_keypoint_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keypoint_index_)));
          set_has_keypoint_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  return false;
#undef DO_
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  // optional int32 descriptor_index = 1;
  if (has_descriptor_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->descriptor_index(), output);
  }

  // optional .common.proto.Id vertex_id = 2;
  if (has_vertex_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->vertex_id(), output);
  }

  // optional uint32 frame_index = 3;
  if (has_frame_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->frame_index(), output);
  }

  // optional uint32 keypoint_index = 4;
  if (has_keypoint_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->keypoint_index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
}

::google::protobuf::uint8* MatchingBasedLoopDetector_DescriptorIndexToKeypoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  // optional int32 descriptor_index = 1;
  if (has_descriptor_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->descriptor_index(), target);
  }

  // optional .common.proto.Id vertex_id = 2;
  if (has_vertex_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->vertex_id(), target);
  }

  // optional uint32 frame_index = 3;
  if (has_frame_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->frame_index(), target);
  }

  // optional uint32 keypoint_index = 4;
  if (has_keypoint_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->keypoint_index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint)
  return target;
}

int MatchingBasedLoopDetector_DescriptorIndexToKeypoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 descriptor_index = 1;
    if (has_descriptor_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->descriptor_index());
    }

    // optional .common.proto.Id vertex_id = 2;
    if (has_vertex_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vertex_id());
    }

    // optional uint32 frame_index = 3;
    if (has_frame_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame_index());
    }

    // optional uint32 keypoint_index = 4;
    if (has_keypoint_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->keypoint_index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatchingBasedLoopDetector_DescriptorIndexToKeypoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatchingBasedLoopDetector_DescriptorIndexToKeypoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::MergeFrom(const MatchingBasedLoopDetector_DescriptorIndexToKeypoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_descriptor_index()) {
      set_descriptor_index(from.descriptor_index());
    }
    if (from.has_vertex_id()) {
      mutable_vertex_id()->::common::proto::Id::MergeFrom(from.vertex_id());
    }
    if (from.has_frame_index()) {
      set_frame_index(from.frame_index());
    }
    if (from.has_keypoint_index()) {
      set_keypoint_index(from.keypoint_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::CopyFrom(const MatchingBasedLoopDetector_DescriptorIndexToKeypoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingBasedLoopDetector_DescriptorIndexToKeypoint::IsInitialized() const {

  return true;
}

void MatchingBasedLoopDetector_DescriptorIndexToKeypoint::Swap(MatchingBasedLoopDetector_DescriptorIndexToKeypoint* other) {
  if (other != this) {
    std::swap(descriptor_index_, other->descriptor_index_);
    std::swap(vertex_id_, other->vertex_id_);
    std::swap(frame_index_, other->frame_index_);
    std::swap(keypoint_index_, other->keypoint_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatchingBasedLoopDetector_DescriptorIndexToKeypoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatchingBasedLoopDetector_DescriptorIndexToKeypoint_descriptor_;
  metadata.reflection = MatchingBasedLoopDetector_DescriptorIndexToKeypoint_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MatchingBasedLoopDetector_DatabaseEntry::kVertexIdFieldNumber;
const int MatchingBasedLoopDetector_DatabaseEntry::kFrameIndexFieldNumber;
const int MatchingBasedLoopDetector_DatabaseEntry::kProjectedImageFieldNumber;
#endif  // !_MSC_VER

MatchingBasedLoopDetector_DatabaseEntry::MatchingBasedLoopDetector_DatabaseEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
}

void MatchingBasedLoopDetector_DatabaseEntry::InitAsDefaultInstance() {
  vertex_id_ = const_cast< ::common::proto::Id*>(&::common::proto::Id::default_instance());
  projected_image_ = const_cast< ::loop_closure::proto::ProjectedImage*>(&::loop_closure::proto::ProjectedImage::default_instance());
}

MatchingBasedLoopDetector_DatabaseEntry::MatchingBasedLoopDetector_DatabaseEntry(const MatchingBasedLoopDetector_DatabaseEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
}

void MatchingBasedLoopDetector_DatabaseEntry::SharedCtor() {
  _cached_size_ = 0;
  vertex_id_ = NULL;
  frame_index_ = 0u;
  projected_image_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingBasedLoopDetector_DatabaseEntry::~MatchingBasedLoopDetector_DatabaseEntry() {
  // @@protoc_insertion_point(destructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  SharedDtor();
}

void MatchingBasedLoopDetector_DatabaseEntry::SharedDtor() {
  if (this != default_instance_) {
    delete vertex_id_;
    delete projected_image_;
  }
}

void MatchingBasedLoopDetector_DatabaseEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_DatabaseEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatchingBasedLoopDetector_DatabaseEntry_descriptor_;
}

const MatchingBasedLoopDetector_DatabaseEntry& MatchingBasedLoopDetector_DatabaseEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  return *default_instance_;
}

MatchingBasedLoopDetector_DatabaseEntry* MatchingBasedLoopDetector_DatabaseEntry::default_instance_ = NULL;

MatchingBasedLoopDetector_DatabaseEntry* MatchingBasedLoopDetector_DatabaseEntry::New() const {
  return new MatchingBasedLoopDetector_DatabaseEntry;
}

void MatchingBasedLoopDetector_DatabaseEntry::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_vertex_id()) {
      if (vertex_id_ != NULL) vertex_id_->::common::proto::Id::Clear();
    }
    frame_index_ = 0u;
    if (has_projected_image()) {
      if (projected_image_ != NULL) projected_image_->::loop_closure::proto::ProjectedImage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatchingBasedLoopDetector_DatabaseEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .common.proto.Id vertex_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vertex_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_frame_index;
        break;
      }

      // optional uint32 frame_index = 2;
      case 2: {
        if (tag == 16) {
         parse_frame_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_index_)));
          set_has_frame_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_projected_image;
        break;
      }

      // optional .loop_closure.proto.ProjectedImage projected_image = 3;
      case 3: {
        if (tag == 26) {
         parse_projected_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_projected_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  return false;
#undef DO_
}

void MatchingBasedLoopDetector_DatabaseEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  // optional .common.proto.Id vertex_id = 1;
  if (has_vertex_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->vertex_id(), output);
  }

  // optional uint32 frame_index = 2;
  if (has_frame_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->frame_index(), output);
  }

  // optional .loop_closure.proto.ProjectedImage projected_image = 3;
  if (has_projected_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->projected_image(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
}

::google::protobuf::uint8* MatchingBasedLoopDetector_DatabaseEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  // optional .common.proto.Id vertex_id = 1;
  if (has_vertex_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->vertex_id(), target);
  }

  // optional uint32 frame_index = 2;
  if (has_frame_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->frame_index(), target);
  }

  // optional .loop_closure.proto.ProjectedImage projected_image = 3;
  if (has_projected_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->projected_image(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry)
  return target;
}

int MatchingBasedLoopDetector_DatabaseEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .common.proto.Id vertex_id = 1;
    if (has_vertex_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vertex_id());
    }

    // optional uint32 frame_index = 2;
    if (has_frame_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame_index());
    }

    // optional .loop_closure.proto.ProjectedImage projected_image = 3;
    if (has_projected_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->projected_image());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingBasedLoopDetector_DatabaseEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatchingBasedLoopDetector_DatabaseEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatchingBasedLoopDetector_DatabaseEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatchingBasedLoopDetector_DatabaseEntry::MergeFrom(const MatchingBasedLoopDetector_DatabaseEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vertex_id()) {
      mutable_vertex_id()->::common::proto::Id::MergeFrom(from.vertex_id());
    }
    if (from.has_frame_index()) {
      set_frame_index(from.frame_index());
    }
    if (from.has_projected_image()) {
      mutable_projected_image()->::loop_closure::proto::ProjectedImage::MergeFrom(from.projected_image());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatchingBasedLoopDetector_DatabaseEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatchingBasedLoopDetector_DatabaseEntry::CopyFrom(const MatchingBasedLoopDetector_DatabaseEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingBasedLoopDetector_DatabaseEntry::IsInitialized() const {

  return true;
}

void MatchingBasedLoopDetector_DatabaseEntry::Swap(MatchingBasedLoopDetector_DatabaseEntry* other) {
  if (other != this) {
    std::swap(vertex_id_, other->vertex_id_);
    std::swap(frame_index_, other->frame_index_);
    std::swap(projected_image_, other->projected_image_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatchingBasedLoopDetector_DatabaseEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatchingBasedLoopDetector_DatabaseEntry_descriptor_;
  metadata.reflection = MatchingBasedLoopDetector_DatabaseEntry_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MatchingBasedLoopDetector_InvertedMultiIndexInterface::kInvertedMultiIndexFieldNumber;
#endif  // !_MSC_VER

MatchingBasedLoopDetector_InvertedMultiIndexInterface::MatchingBasedLoopDetector_InvertedMultiIndexInterface()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::InitAsDefaultInstance() {
  inverted_multi_index_ = const_cast< ::loop_closure::proto::InvertedMultiIndex*>(&::loop_closure::proto::InvertedMultiIndex::default_instance());
}

MatchingBasedLoopDetector_InvertedMultiIndexInterface::MatchingBasedLoopDetector_InvertedMultiIndexInterface(const MatchingBasedLoopDetector_InvertedMultiIndexInterface& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::SharedCtor() {
  _cached_size_ = 0;
  inverted_multi_index_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingBasedLoopDetector_InvertedMultiIndexInterface::~MatchingBasedLoopDetector_InvertedMultiIndexInterface() {
  // @@protoc_insertion_point(destructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  SharedDtor();
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::SharedDtor() {
  if (this != default_instance_) {
    delete inverted_multi_index_;
  }
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_InvertedMultiIndexInterface::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatchingBasedLoopDetector_InvertedMultiIndexInterface_descriptor_;
}

const MatchingBasedLoopDetector_InvertedMultiIndexInterface& MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  return *default_instance_;
}

MatchingBasedLoopDetector_InvertedMultiIndexInterface* MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance_ = NULL;

MatchingBasedLoopDetector_InvertedMultiIndexInterface* MatchingBasedLoopDetector_InvertedMultiIndexInterface::New() const {
  return new MatchingBasedLoopDetector_InvertedMultiIndexInterface;
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::Clear() {
  if (has_inverted_multi_index()) {
    if (inverted_multi_index_ != NULL) inverted_multi_index_->::loop_closure::proto::InvertedMultiIndex::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatchingBasedLoopDetector_InvertedMultiIndexInterface::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .loop_closure.proto.InvertedMultiIndex inverted_multi_index = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inverted_multi_index()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  return false;
#undef DO_
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  // optional .loop_closure.proto.InvertedMultiIndex inverted_multi_index = 1;
  if (has_inverted_multi_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverted_multi_index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
}

::google::protobuf::uint8* MatchingBasedLoopDetector_InvertedMultiIndexInterface::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  // optional .loop_closure.proto.InvertedMultiIndex inverted_multi_index = 1;
  if (has_inverted_multi_index()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverted_multi_index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface)
  return target;
}

int MatchingBasedLoopDetector_InvertedMultiIndexInterface::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .loop_closure.proto.InvertedMultiIndex inverted_multi_index = 1;
    if (has_inverted_multi_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inverted_multi_index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatchingBasedLoopDetector_InvertedMultiIndexInterface* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatchingBasedLoopDetector_InvertedMultiIndexInterface*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::MergeFrom(const MatchingBasedLoopDetector_InvertedMultiIndexInterface& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_inverted_multi_index()) {
      mutable_inverted_multi_index()->::loop_closure::proto::InvertedMultiIndex::MergeFrom(from.inverted_multi_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::CopyFrom(const MatchingBasedLoopDetector_InvertedMultiIndexInterface& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingBasedLoopDetector_InvertedMultiIndexInterface::IsInitialized() const {

  return true;
}

void MatchingBasedLoopDetector_InvertedMultiIndexInterface::Swap(MatchingBasedLoopDetector_InvertedMultiIndexInterface* other) {
  if (other != this) {
    std::swap(inverted_multi_index_, other->inverted_multi_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatchingBasedLoopDetector_InvertedMultiIndexInterface::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatchingBasedLoopDetector_InvertedMultiIndexInterface_descriptor_;
  metadata.reflection = MatchingBasedLoopDetector_InvertedMultiIndexInterface_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::kVertexIdFieldNumber;
const int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::kFrameIndexFieldNumber;
#endif  // !_MSC_VER

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::InitAsDefaultInstance() {
  vertex_id_ = const_cast< ::common::proto::Id*>(&::common::proto::Id::default_instance());
}

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId(const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::SharedCtor() {
  _cached_size_ = 0;
  vertex_id_ = NULL;
  frame_index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::~MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId() {
  // @@protoc_insertion_point(destructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  SharedDtor();
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::SharedDtor() {
  if (this != default_instance_) {
    delete vertex_id_;
  }
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_descriptor_;
}

const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId& MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  return *default_instance_;
}

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance_ = NULL;

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::New() const {
  return new MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId;
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_vertex_id()) {
      if (vertex_id_ != NULL) vertex_id_->::common::proto::Id::Clear();
    }
    frame_index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .common.proto.Id vertex_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vertex_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_frame_index;
        break;
      }

      // optional uint32 frame_index = 2;
      case 2: {
        if (tag == 16) {
         parse_frame_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_index_)));
          set_has_frame_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  return false;
#undef DO_
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  // optional .common.proto.Id vertex_id = 1;
  if (has_vertex_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->vertex_id(), output);
  }

  // optional uint32 frame_index = 2;
  if (has_frame_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->frame_index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
}

::google::protobuf::uint8* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  // optional .common.proto.Id vertex_id = 1;
  if (has_vertex_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->vertex_id(), target);
  }

  // optional uint32 frame_index = 2;
  if (has_frame_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->frame_index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId)
  return target;
}

int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .common.proto.Id vertex_id = 1;
    if (has_vertex_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vertex_id());
    }

    // optional uint32 frame_index = 2;
    if (has_frame_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame_index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::MergeFrom(const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vertex_id()) {
      mutable_vertex_id()->::common::proto::Id::MergeFrom(from.vertex_id());
    }
    if (from.has_frame_index()) {
      set_frame_index(from.frame_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::CopyFrom(const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::IsInitialized() const {

  return true;
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::Swap(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId* other) {
  if (other != this) {
    std::swap(vertex_id_, other->vertex_id_);
    std::swap(frame_index_, other->frame_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_descriptor_;
  metadata.reflection = MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::kKeyframeIdFieldNumber;
const int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::kNumDescriptorsFieldNumber;
#endif  // !_MSC_VER

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::InitAsDefaultInstance() {
  keyframe_id_ = const_cast< ::matching_based_loopclosure::proto::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId*>(&::matching_based_loopclosure::proto::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::default_instance());
}

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors(const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::SharedCtor() {
  _cached_size_ = 0;
  keyframe_id_ = NULL;
  num_descriptors_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::~MatchingBasedLoopDetector_KeyframeIdToNumDescriptors() {
  // @@protoc_insertion_point(destructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  SharedDtor();
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::SharedDtor() {
  if (this != default_instance_) {
    delete keyframe_id_;
  }
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_;
}

const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors& MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  return *default_instance_;
}

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::default_instance_ = NULL;

MatchingBasedLoopDetector_KeyframeIdToNumDescriptors* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::New() const {
  return new MatchingBasedLoopDetector_KeyframeIdToNumDescriptors;
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_keyframe_id()) {
      if (keyframe_id_ != NULL) keyframe_id_->::matching_based_loopclosure::proto::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::Clear();
    }
    num_descriptors_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId keyframe_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keyframe_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_num_descriptors;
        break;
      }

      // optional uint32 num_descriptors = 3;
      case 3: {
        if (tag == 24) {
         parse_num_descriptors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_descriptors_)));
          set_has_num_descriptors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  return false;
#undef DO_
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId keyframe_id = 1;
  if (has_keyframe_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->keyframe_id(), output);
  }

  // optional uint32 num_descriptors = 3;
  if (has_num_descriptors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num_descriptors(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
}

::google::protobuf::uint8* MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId keyframe_id = 1;
  if (has_keyframe_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->keyframe_id(), target);
  }

  // optional uint32 num_descriptors = 3;
  if (has_num_descriptors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->num_descriptors(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors)
  return target;
}

int MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors.KeyframeId keyframe_id = 1;
    if (has_keyframe_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keyframe_id());
    }

    // optional uint32 num_descriptors = 3;
    if (has_num_descriptors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_descriptors());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::MergeFrom(const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keyframe_id()) {
      mutable_keyframe_id()->::matching_based_loopclosure::proto::MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_KeyframeId::MergeFrom(from.keyframe_id());
    }
    if (from.has_num_descriptors()) {
      set_num_descriptors(from.num_descriptors());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::CopyFrom(const MatchingBasedLoopDetector_KeyframeIdToNumDescriptors& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::IsInitialized() const {

  return true;
}

void MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::Swap(MatchingBasedLoopDetector_KeyframeIdToNumDescriptors* other) {
  if (other != this) {
    std::swap(keyframe_id_, other->keyframe_id_);
    std::swap(num_descriptors_, other->num_descriptors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatchingBasedLoopDetector_KeyframeIdToNumDescriptors::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_descriptor_;
  metadata.reflection = MatchingBasedLoopDetector_KeyframeIdToNumDescriptors_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MatchingBasedLoopDetector::kDescriptorIndexToKeypointFieldNumber;
const int MatchingBasedLoopDetector::kDatabaseEntriesFieldNumber;
const int MatchingBasedLoopDetector::kDescriptorIndexFieldNumber;
const int MatchingBasedLoopDetector::kInvertedMultiIndexInterfaceFieldNumber;
const int MatchingBasedLoopDetector::kKeyframeIdToNumDescriptorsFieldNumber;
#endif  // !_MSC_VER

MatchingBasedLoopDetector::MatchingBasedLoopDetector()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
}

void MatchingBasedLoopDetector::InitAsDefaultInstance() {
  inverted_multi_index_interface_ = const_cast< ::matching_based_loopclosure::proto::MatchingBasedLoopDetector_InvertedMultiIndexInterface*>(&::matching_based_loopclosure::proto::MatchingBasedLoopDetector_InvertedMultiIndexInterface::default_instance());
}

MatchingBasedLoopDetector::MatchingBasedLoopDetector(const MatchingBasedLoopDetector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
}

void MatchingBasedLoopDetector::SharedCtor() {
  _cached_size_ = 0;
  descriptor_index_ = 0;
  inverted_multi_index_interface_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingBasedLoopDetector::~MatchingBasedLoopDetector() {
  // @@protoc_insertion_point(destructor:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  SharedDtor();
}

void MatchingBasedLoopDetector::SharedDtor() {
  if (this != default_instance_) {
    delete inverted_multi_index_interface_;
  }
}

void MatchingBasedLoopDetector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatchingBasedLoopDetector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatchingBasedLoopDetector_descriptor_;
}

const MatchingBasedLoopDetector& MatchingBasedLoopDetector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_matching_2dbased_2dloopclosure_2fmatching_5fbased_5floop_5fdetector_2eproto();
  return *default_instance_;
}

MatchingBasedLoopDetector* MatchingBasedLoopDetector::default_instance_ = NULL;

MatchingBasedLoopDetector* MatchingBasedLoopDetector::New() const {
  return new MatchingBasedLoopDetector;
}

void MatchingBasedLoopDetector::Clear() {
  if (_has_bits_[0 / 32] & 12) {
    descriptor_index_ = 0;
    if (has_inverted_multi_index_interface()) {
      if (inverted_multi_index_interface_ != NULL) inverted_multi_index_interface_->::matching_based_loopclosure::proto::MatchingBasedLoopDetector_InvertedMultiIndexInterface::Clear();
    }
  }
  descriptor_index_to_keypoint_.Clear();
  database_entries_.Clear();
  keyframe_id_to_num_descriptors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatchingBasedLoopDetector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint descriptor_index_to_keypoint = 1;
      case 1: {
        if (tag == 10) {
         parse_descriptor_index_to_keypoint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_descriptor_index_to_keypoint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_descriptor_index_to_keypoint;
        if (input->ExpectTag(18)) goto parse_database_entries;
        break;
      }

      // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry database_entries = 2;
      case 2: {
        if (tag == 18) {
         parse_database_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_database_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_database_entries;
        if (input->ExpectTag(24)) goto parse_descriptor_index;
        break;
      }

      // optional int32 descriptor_index = 3;
      case 3: {
        if (tag == 24) {
         parse_descriptor_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &descriptor_index_)));
          set_has_descriptor_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_inverted_multi_index_interface;
        break;
      }

      // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface inverted_multi_index_interface = 4;
      case 4: {
        if (tag == 34) {
         parse_inverted_multi_index_interface:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inverted_multi_index_interface()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_keyframe_id_to_num_descriptors;
        break;
      }

      // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors keyframe_id_to_num_descriptors = 5;
      case 5: {
        if (tag == 42) {
         parse_keyframe_id_to_num_descriptors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keyframe_id_to_num_descriptors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_keyframe_id_to_num_descriptors;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  return false;
#undef DO_
}

void MatchingBasedLoopDetector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint descriptor_index_to_keypoint = 1;
  for (int i = 0; i < this->descriptor_index_to_keypoint_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->descriptor_index_to_keypoint(i), output);
  }

  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry database_entries = 2;
  for (int i = 0; i < this->database_entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->database_entries(i), output);
  }

  // optional int32 descriptor_index = 3;
  if (has_descriptor_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->descriptor_index(), output);
  }

  // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface inverted_multi_index_interface = 4;
  if (has_inverted_multi_index_interface()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->inverted_multi_index_interface(), output);
  }

  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors keyframe_id_to_num_descriptors = 5;
  for (int i = 0; i < this->keyframe_id_to_num_descriptors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->keyframe_id_to_num_descriptors(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
}

::google::protobuf::uint8* MatchingBasedLoopDetector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint descriptor_index_to_keypoint = 1;
  for (int i = 0; i < this->descriptor_index_to_keypoint_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->descriptor_index_to_keypoint(i), target);
  }

  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry database_entries = 2;
  for (int i = 0; i < this->database_entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->database_entries(i), target);
  }

  // optional int32 descriptor_index = 3;
  if (has_descriptor_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->descriptor_index(), target);
  }

  // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface inverted_multi_index_interface = 4;
  if (has_inverted_multi_index_interface()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->inverted_multi_index_interface(), target);
  }

  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors keyframe_id_to_num_descriptors = 5;
  for (int i = 0; i < this->keyframe_id_to_num_descriptors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->keyframe_id_to_num_descriptors(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:matching_based_loopclosure.proto.MatchingBasedLoopDetector)
  return target;
}

int MatchingBasedLoopDetector::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional int32 descriptor_index = 3;
    if (has_descriptor_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->descriptor_index());
    }

    // optional .matching_based_loopclosure.proto.MatchingBasedLoopDetector.InvertedMultiIndexInterface inverted_multi_index_interface = 4;
    if (has_inverted_multi_index_interface()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inverted_multi_index_interface());
    }

  }
  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DescriptorIndexToKeypoint descriptor_index_to_keypoint = 1;
  total_size += 1 * this->descriptor_index_to_keypoint_size();
  for (int i = 0; i < this->descriptor_index_to_keypoint_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->descriptor_index_to_keypoint(i));
  }

  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.DatabaseEntry database_entries = 2;
  total_size += 1 * this->database_entries_size();
  for (int i = 0; i < this->database_entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->database_entries(i));
  }

  // repeated .matching_based_loopclosure.proto.MatchingBasedLoopDetector.KeyframeIdToNumDescriptors keyframe_id_to_num_descriptors = 5;
  total_size += 1 * this->keyframe_id_to_num_descriptors_size();
  for (int i = 0; i < this->keyframe_id_to_num_descriptors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keyframe_id_to_num_descriptors(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingBasedLoopDetector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatchingBasedLoopDetector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatchingBasedLoopDetector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatchingBasedLoopDetector::MergeFrom(const MatchingBasedLoopDetector& from) {
  GOOGLE_CHECK_NE(&from, this);
  descriptor_index_to_keypoint_.MergeFrom(from.descriptor_index_to_keypoint_);
  database_entries_.MergeFrom(from.database_entries_);
  keyframe_id_to_num_descriptors_.MergeFrom(from.keyframe_id_to_num_descriptors_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_descriptor_index()) {
      set_descriptor_index(from.descriptor_index());
    }
    if (from.has_inverted_multi_index_interface()) {
      mutable_inverted_multi_index_interface()->::matching_based_loopclosure::proto::MatchingBasedLoopDetector_InvertedMultiIndexInterface::MergeFrom(from.inverted_multi_index_interface());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatchingBasedLoopDetector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatchingBasedLoopDetector::CopyFrom(const MatchingBasedLoopDetector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingBasedLoopDetector::IsInitialized() const {

  return true;
}

void MatchingBasedLoopDetector::Swap(MatchingBasedLoopDetector* other) {
  if (other != this) {
    descriptor_index_to_keypoint_.Swap(&other->descriptor_index_to_keypoint_);
    database_entries_.Swap(&other->database_entries_);
    std::swap(descriptor_index_, other->descriptor_index_);
    std::swap(inverted_multi_index_interface_, other->inverted_multi_index_interface_);
    keyframe_id_to_num_descriptors_.Swap(&other->keyframe_id_to_num_descriptors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatchingBasedLoopDetector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatchingBasedLoopDetector_descriptor_;
  metadata.reflection = MatchingBasedLoopDetector_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace matching_based_loopclosure

// @@protoc_insertion_point(global_scope)
